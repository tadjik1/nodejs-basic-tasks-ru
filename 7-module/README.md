# Аутентификация/Авторизация

Любой процесс аутентификации/авторизации можно разбить на три этапа:
1. Получение данных пользователя либо от самого пользователя, например, логин и пароль, либо от 
социальной сети, если вход выполняется через нее.
2. Проверка полученных данных. 
3. Принятие решение "подходит" ли нам этот пользователь.

При использовании модуля `passport` этот процесс определяется в сущности под названием "стратегия".
По умолчанию при успешном результате - идентификатор пользователя записывается в сессию, чтобы при
следующем заходе мы могли определить является ли этот пользователь залогиненным.

Официальная документация к модулю passport доступна на 
[официальном сайте](http://www.passportjs.org/).


## OAuth 2.0

[Протокол OAuth 2.0](https://oauth.net/2/) специально создан для решения ситуаций, когда одно 
приложение хочет получить доступ к ресурсам пользователя, который находятся у другого приложения.
Один из самых частых случаев использования - это получение сайтом у социальной сети информации о ее
пользователе: имя, почтовый адрес, аватар и т.д. Огромное количество готовых стратегий позволяет
нам очень легко подключать любые социальные сети, через которые пользователь сможет 
зарегистрироваться или залогиниться на нашем сайте.   


## Сессии

Сессия - это объект, который хранится на сервере (обычно в памяти или базе данных), и который 
ассоциирован с конкретным пользователем. Когда пользователь делает запрос он предоставляет ключ
сессии, и мы таким образом получаем возможность хранить и использовать информацию о нем (например, 
кол-во заходов на страницу, товары, добавленные в избранное и т.д.). Если пользователь заходит 
впервые - то для него генерируется новый объект сессии и передается новый ключ.


Концепция сессий не связана с конкретными технологиями, все, что описано выше может быть успешно 
использовано при использовании любых языков программирования, фреймворков, даже сетевых протоколов. 
Однако традиционно при разработке веб-приложений для передачи ключа сессии используются cookie 
браузера. Это позволяет удобно создавать, читать и менять ключ, без необходимости уведомлять об этом
клиента.


При использовании фреймворка Koa.js у нас нет необходимости управлять процессом генерации ключей и
хранения сессий вручную - мы можем это поручить модулю под названием `koa-session`. После 
подключения он начинает следить и за объектами сессий и за содержимым cookie пользователя. Читать и
записывать любые значения в сессию пользователя мы можем с помощью свойства `ctx.session`.

Официальная документация к модулю koa-session доступна на 
[официальном сайте](https://github.com/koajs/session).      


## Шаблонизация

Какое бы приложение мы не разрабатывали нам в любом случае потребуется работать с генерацией HTML,
потому что именно этот формат необходим браузерам для отображения страниц. По своей сути формат HTML
является строковым, таким образом наша задача сводится к генерации строк. Однако даже небольшая
страница содержит довольно много кода, кроме того практически все страницы одного проекта содержат
множество повторяющихся конструкций.

В наших проектах для шаблонизации мы будем пользоваться модулем `pug`, который предоставляет удобный
синтаксис и большое количество конструкций для динамического формирования HTML на основании 
переменных, циклов и так далее.

Официальная документация к модулю pug доступна на [официальном сайте](https://pugjs.org).


## Флеш-сообщения

Зачастую при разработке веб-приложений у нас возникает необходимость сообщить пользователю 
информацию о том, как завершилась та или иная операция, например добавление товара в корзину или
попытка логина. Сделать это можно двумя способами:
- с помощью клиентского кода
- с помощью технологии флеш-сообщений


Так как наш фокус - это именно серверная разработка мы будем использовать второй способ, который
позволяет обойтись без клиентского кода. Суть этого подхода довольно проста:
- мы сохраняем сообщение, которое нужно показать в сессии пользователя
- при следующем запросе проверяем есть ли какие-то сообщения в сессии
- включаем их в сгенерированную страничку
- удаляем сообщения из сессии


Возможно, последний шаг на первый взгляд выглядит не совсем очевидным, однако он очень важен для
правильной работы этой технологии. Дело в том, что мы хотим показать то или иное сообщение лишь один
раз, при следующем запросе, но не каждый раз, когда пользователь открывает наш сайт. Представьте
сайт, который пишет вам каждый раз как вы на него заходите, что вы ввели неправильный пароль (даже
если вы пытались войти несколько дней назад).
