# Порядок вывода сообщений в консоль
 
Понимание того, как именно выполняется тот или иной код - чрезвычайно важное качество, отличающее действительно хороших
разработчиков.

Выполнение любой программы на Javascript "раскладывается" на итерации событийного цикла. Однако не все асинхронные 
операции обязательно выполняются на последующей итерации, некоторые из них могут выполняться в рамках текущей, но в 
конце, после синхронного кода. 
В данной задаче у всех таймеров и интервалов установлена одинаковая ненулевая задержка в
10 мс, это сделано для того, чтобы нам проще было мысленно "выполнять" код, подразумевая, что коллбеки всех операций 
будут выполняться в том порядке, в котором и были объявлены. В реальной жизни операции имеют разное время выполнения, 
разную сложность и иногда даже разный приоритет, но принципиально это ничего не меняет.

Проще всего понять происходящее поможет концепция очередей задач и микрозадач. В очередь задач помещаются операции, 
коллбеки от которых будут выполнены на следующих итерациях событийного цикла (setTimeout, fs.readFile и т.д.), 
а в очередь микрозадач - асинхронные операции, выполнение коллбеков которых произойдет в конце текущей итерации, после 
синхронного кода. Это, например: Promise, process.nextTick.

Таким образом, любой код можно мысленно выполнить и в процессе выполнения разложить на итерации событийного цикла.

Давайте приступим к разбору исходного кода.
Для выполнения кода создадим две очереди - два массива для задач (tasks = []) и микрозадач (microtasks = []).
Начинается первая итерация событийного цикла, ее иницировал процесс Node.JS. Обе очереди пусты.
```js
tasks = []
microtasks = []
``` 
На строке 1 мы видим операцию setInterval, в результате которой через каждые 10мс в консоль будет выводиться имя 
James. Мы знаем, что коллбек этой операции не будет выполнен сразу же, а будет добавлен в очередь задач. Для простоты
поместим в наш массив сразу то имя, которое будет выведено в консоль.
```js
tasks = ['James']
microtasks = []
 ``` 

Далее на строке 5 операция setTimeout, коллбек которой также попадет в очередь задач:
```js
tasks = ['James', 'John']
microtasks = []
```
Мы рассмотрим код внутри коллбека тогда, когда придет его очередь.

На строке 24 мы видим создание промиса и синхронный его resolve (функция, передаваемая в конструктор промиса 
выполняется сразу же - на месте). Промисы относятся к микрозадачам, добавим его в соответствующий массив:
```js
tasks = ['James', 'John']
microtasks = ['William']
```
На данный момент мы выполнили весь синхронный код, и проверяем - есть ли что-то в очереди микрозадач.
Оказывается, что есть - это .then коллбек промиса.
```js
tasks = ['James', 'John']
microtasks = [] // <--- "достаем" 'William' из очереди
```
Выполнение продолжается со строки 30, с которой друг за другом выполняются две синхронных операции: вывод в консоль 
сначала имени William, а затем David. Следом создается новый промис, внутри которого - setTimeout. В данном случае 
создается новая задача, которую мы добавим в нашу очередь.
```js
// Консоль
/*
    William
    David
*/

tasks = ['James', 'John', 'Joseph']
microtasks = []
```

Весь синхронный код текущей итерации выполнен, кроме этого выполнены все микрозадачи из соответствующей очереди - первая
итерация событийного цикла завершается.

Следующая итерация начинается с выполнения первого коллбека в очереди задач, в нашем случае - это коллбек операции 
setInterval. В данном случае в консоль будет выведено имя James, а сам коллбек будет добавлен в конец очереди задач.
```js
// Консоль
/*
    William
    David
    James
*/

tasks = ['John', 'Joseph', 'James']
microtasks = []
```
Весь синхронный код выполнен, очередь микрозадач пуста - текущая итерация событийного цикла заверщается.

Новая итерация начинается с коллбека для операции setTimeout, на строке 6.
Первым делом в консоль выводится имя John:
```js
// Консоль
/*
    William
    David
    James
    John
*/

tasks = ['Joseph', 'James']
microtasks = []
```
Затем создается и сразу же резолвится промис со значением Robert:
```js
// Консоль
/*
    William
    David
    James
    John
*/

tasks = ['Joseph', 'James']
microtasks = ['Robert']
```
Весь синхронный код выполнен, однако остается невыполненной микрозадача, внутри коллбека которой мы видим операцию 
setTimeout. Результат выполнения коллбека будет выглядеть следующим образом:
```js
// Консоль
/*
    William
    David
    James
    John
    Robert
*/

tasks = ['Joseph', 'James', 'Michael']
microtasks = []
```

Следующая, четвертая по счету итерация начинается с коллбека для операции setTimeout на 38 строчке. Здесь есть 
синхронный код, который выполняется на месте (вывод имени Joseph в консоль), а также резолв промиса, в результате 
которого коллбек .then будет помещен в очередь микрозадач:
```js
// Консоль
/*
    William
    David
    James
    John
    Robert
    Joseph
*/

tasks = ['James', 'Michael']
microtasks = ['Richard']
```
Как и раньше мы получили ситуацию, когда весь синхронный код выполнен, однако есть операция в очереди микрозадач. При 
выполнении результат будет таким:
```js
// Консоль
/*
    William
    David
    James
    John
    Robert
    Joseph
    Richard
*/

tasks = ['James', 'Michael']
microtasks = []
```

Наша пятая итерация начинается как и вторая - с коллбека setInterval, в результате будет выполнен синхронный вывод в 
консоль имени James, а также добавлена новая задача в очередь (с тем же самым коллбеком).
```js
// Консоль
/*
    William
    David
    James
    John
    Robert
    Joseph
    Richard
    James
*/

tasks = ['Michael', 'James']
microtasks = []
```

Шестая итерация начинается с выполнения коллбека на 17 строчке. Здесь мы видим синхронный вывод в консоль имени Michael,
а также отмену операции setInterval. В результате картина выполнения получится следующей:
```js
// Консоль
/*
    William
    David
    James
    John
    Robert
    Joseph
    Richard
    James
    Michael
*/

tasks = []
microtasks = []
```

Больше нет ни синхронного, ни асинхронного кода для выполнения - обе очереди пусты, происходит выход из процесса.
