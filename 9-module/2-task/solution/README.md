# Чат с использованием websockets (Решение)


## GET /messages
Поиск сообщений выполняется с помощью операции `.find`, при этом никаких параметров поиска 
передавать не нужно - нас интересует вся история сообщений.
Однако некоторые моменты при выполнении запроса к базе данных стоит учесть. А именно:
1. Сортировка. Мы с вами хотим получить сообщения в обратном хронологическом порядке, то есть 
сначала самые новые. Для этого после вызова `.find()` добавим вызов `.sort({ date: 1 })`.
2. Количество элементов. Обычно мессенджеры при старте не загружают всю историю чата, это было бы
слишком долго, а ограничиваются некоторым количеством сообщением. При желании пользователь может
дозагрузить предыдущие сообщения позже. Для того, чтобы получить из базы лишь 20 сообщений добавим
вызов `.limit(20)`.
3. Ну и конечно не будет лишним "развернуть" идентификатор пользователя, который хранится в каждом
сообщении в полноценный объект пользователя. Сделать это можно с помощью операции `populate('user')`

В итоге запрос к базе данных будет выглядеть следующим образом:
```js
const messages = await Message.find().sort({ date: 1 }).limit(20).populate('user');
```

Теперь осталось лишь выполнить простой мапинг документов в объекты, требующиеся клиенту:
```js
const Message = require('../models/Message');

module.exports = async function messages(ctx, next) {
  const messages = await Message.find().sort({ date: 1 }).limit(20).populate('user');
  
  ctx.body = {
    messages: messages.map(message => ({
      date: message.date,
      text: message.text,
      id: message.id,
      user: message.user.displayName,
    }))
  };
};

``` 

## Аутентификация Websocket

Механизмы аутентификации для Websocket можно разделить на 2 основных вида:
1. Аутентификация на основании данных, передаваемых при установке соединения по HTTP.
2. Разрешение подключения всем клиентам с заданным таймаутом для передачи ими аутентификационных 
данных. Например: мы разрешаем подключение всем пользователям, но при первоначальном соединении 
помечаем такого клиента как непроверенного, не имеющего возможности ни получать, ни отправлять 
никакие сообщения. Таким клиентам даётся некоторое время, скажем, 5 секунд, для того, чтобы 
отправить свои аутентификационные данные (токен, логин/пароль, что-то другое). Если данные неверны
или вовсе не были отправлены - сервер принудительно завершает такое соединение.

Ввиду простоты реализации мы с вами остановимся именно на первом подходе, который не требует никаких
специальных условий для своей работы и отлично поддерживается всеми клиентами.

Для того, чтобы "вклиниться" в процесс подключения клиента и добавить логику аутентификации в 
библиотеке `socket.io` есть функция `io.use((socket, next) => {});`. Эта функция с одной стороны 
даёт нам доступ к оригинальному http запросу (его данные можно получить с помощью 
`socket.handshake`, с другой стороны возможность асинхронно выполнить любые проверки и вызвать 
функцию `done`, в которую можно передать объект ошибки (и прекратить попытку подключения), либо 
вызвать её без аргументов и позволить клиенту подключиться.

Логика аутентификации может выглядеть следующим образом:
```js
  io.use(async function(socket, next) {
    const token = socket.handshake.query.token;
    
    if (!token) return next(new Error('anonymous sessions are not allowed'));
    
    const session = await Session.findOne({token}).populate('user');
    
    if (!session) return next(new Error('wrong or expired session token'));

    socket.user = session.user;
    
    next();
  });
```

## Обработка пользовательских сообщений

Для отправки сообщения *всем* подключенным пользователям необходимо использовать метод `io.emit`. 
Названием события будет `user_message` (в будущем могут появиться и другие типы сообщений). Объект 
сообщения строится следующим образом:
```js
socket.on('message', async msg => {
  const date = new Date();
  
  io.emit('user_message', {
    user: socket.user.displayName,
    text: msg,
    date: date
  });
});
```
То есть мы используем оригинальный текст сообщения пользователя, текущую дату и имя пользователя,
которое мы получили на этапе аутентификации.

После этого осталось лишь сохранить сообщение в базе данных:
```js
socket.on('message', async msg => {
  const date = new Date();
  
  io.emit('user_message', {
    user: socket.user.displayName,
    text: msg,
    date: date
  });
  
  await Message.create({
    user: socket.user.id,
    text: msg,
    date: date,
  });
});
``` 
