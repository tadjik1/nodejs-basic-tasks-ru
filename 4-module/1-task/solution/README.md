# Файловый сервер (Решение)

Разобьем решение на три отдельных функции, для отдачи файла, для получения и удаления.
Сразу отметим, что отдача и получения файла должны быть реализованы через стримы, для того, чтобы максимально эффективно
использовать память компьютера.


## Отдача файла
Для того, чтобы отдать файл пользователю необходимо создать стрим для чтения из файла с помощью функции 
`createReadStream` модуля `fs` и перенаправить его вывод в поток для записи `res`, который является также потоком ответа
сервера. У нас уже есть переменная `filepath`, которая содержит путь до файла, так что код будет выглядеть следующим 
образом: 
```js
const stream = fs.createReadStream(filepath);
stream.pipe(res);
```


Основная задача выполнена, однако остаются несколько моментов, про которые легко забыть, но которые очень серьезно
могут повлиять на надежность нашего сервера. Это обработка возможных ошибок, а также потенциальная ситуация обрыва
соединения клиентом.


В данном случае при обработке ошибок нам особенно интересна ситуация когда она возникает по причине отсутствия файла, 
т.к. в этом случае мы должны вернуть специальный статус `404`. Отследить именно эту ошибку нам поможет свойство `code`,
которое содержит код ошибки. В модуле 
[`errors`](https://nodejs.org/dist/latest/docs/api/errors.html#errors_common_system_errors) можно посмотреть все коды 
системных ошибок и их описание, нас интересует ошибка с кодом `ENOENT`, во всех остальных случаях будем просто отдавать 
стандартный для таких случаев статус ответа `500`.

```js
stream.on('error', error => {
  if (error.code === 'ENOENT') {
    res.statusCode = 404;
    res.end('File not found');
  } else {
    res.statusCode = 500;
    res.end('Internal server error');
  }
});
``` 


Ситуация обрыва соединения не так критична для работы нашего сервера, т.к. никаких ошибок не произойдет, а Node.JS 
продолжит считывать потоково файл до самого конца. Однако мы можем избежать этой ненужной работы и потратить ресурсы 
сервера на более полезные задачи.


Закрытие соединения можно отследить с помощью события `close` и если в этот момент обработка запроса еще не завершена 
(свойство `finished` равняется `false`), значит произошел обрыв. В этом случае нам достаточно вызвать метод `.destroy` 
у объекта файлового стрима для того, чтобы высвободить занимаемые им ресурсы.
```js
res.on('close', () => {
  if (res.finished) return;
  stream.destroy();
});
```


Проверку вложенных папок можно выполнить просто проверкой наличия слешей или точек в ссылке запроса:
```js
if (pathname.includes('/') || pathname.includes('..')) {
  res.statusCode = 400;
  res.end('Nested paths are not allowed');
}
```

## Удаление файла
Для удаления файла используем функцию `unlink` модуля `fs`. В качестве аргумента она принимает путь до файла и возвращает
либо объект с ошибкой (если что-то пошло не так), либо ничего. Из ошибок как и в прошлом случае нам особенно интересна 
лишь одна, которая сообщит нам если файла с таким именем на диске нет (ее код - `ENOENT`). Все остальные ошибки 
обработаем стандартным способом, отправив пользователю статус `500`. Если ошибок не было - значит файл успешно удален.
```js
fs.unlink(filepath, error => {
  if (error) {
    if (error.code === 'ENOENT') {
      res.statusCode = 404;
      res.end('Not found');
    } else {
      res.statusCode = 500;
      res.end('Internal error');  
    }
  } else {
    res.statusCode = 200;
    res.end('Ok');
  }
});
``` 

## Загрузка файла
Как и в случае с отдачей файла главная цель при загрузке — создать файловый стрим. Однако теперь мы будем писать 
информацию из запроса в файл, а не наоборот. Код будет выглядеть следующим образом:
```js
const stream = fs.createWriteStream(filepath);
req.pipe(stream);
```

Однако поведение по умолчанию функции `createWriteStream` нам не подходит. Дело в том, что файл будет перезаписан 
новым содержимым, если он уже есть на диске, а нам надо в этом случае возвращать пользователю ошибку. С помощью 
свойства `flags`, описанного в 
[документации](https://nodejs.org/dist/latest/docs/api/fs.html#fs_fs_createwritestream_path_options) мы можем достичь 
нужного нам поведения, значение `wx` как раз позволит нам перехватить ошибку если файл уже находится на диске, не 
перезаписывая его. Код ошибки в этом случае будет `EEXIST`.


Не стоит забывать, что ошибки могут происходить не только в начале передачи (пока файла еще нет на диске), но и в 
процессе передачи - в этом случае стоит убедиться, что на диске не осталось части файла, которую мы могли успеть 
записать. Для этого безопаснее всего будет вызвать функцию `fs.unlink`. 

```js
const stream = fs.createWriteStream(filepath, {flags: 'wx'});
req.pipe(stream);
stream.on('error', error => {
  if (error.code === 'EEXIST') {
    res.statusCode = 409;
    res.end('File exists');
  } else {
    res.statusCode = 500;
    res.end('Internal server error');
    fs.unlink(filepath, error => {});
  }
});
```


В какой момент мы понимаем, что файл успешно записан на диск и мы можем сообщить пользователю, что все завершилось 
успешно? У нас есть несколько событий с очень похожим смыслом: `req.on('end', ...)`, `stream.on('finish', ...)` и
`stream.on('close', ...)`, какое же стоит выбрать? Давайте разберем каждое по отдельности:
1. `req.on('end', ...)` - событие буквально означает "считывание данных из тела запроса завершено". в каком статусе 
находится в этот момент запись это событие нам не сообщает, так что использовать его мы не можем.
2. `stream.on('finish')` - это событие намного ближе по сути, т.к. оно означает "стрим закончил передачу данных на 
запись". но и оно не означает, что запись завершена успешно.
3. `stream.on('close')` - лишь на событие, которое означает "файл был полностью записан на диск", мы можем полагаться.

Дополним наш код:
```js
stream.on('close', () => {
  res.end('file has been saved');
});
```    


Очень важная деталь касается обработки обрыва соединения: мы обязательно должны отслеживать эту ситуацию, т.к. в 
результате обрыва часть файла останется на диске. Чтобы избежать проблем при обрыве соединения мы должны файл удалять:
```js
res.on('close', () => {
  if (res.finished) return;
  fs.unlink(filepath, error => {});
});
``` 


Осталось лишь решить проблему со слишком большим файлом, так как мы не хотим, чтобы пользователи забили нам диск.
Большинство браузеров при отправке файлов через форму отправляют специальный заголовок `Content-Length` с размером файла
в байтах. Также поступают и многие другие клиенты, так что первым делом мы можем проверить наличие и содержимое этого
заголовка, если размер файла больше, чем мы ожидаем - пользователю можно сразу вернуть ошибку.

```js
if (req.headers['content-length'] > 1e6) {
  res.statusCode = 413;
  res.end('File is too big!');
  return;
}
```


Однако далеко не всегда этот заголовок присутствует, и даже по стандарту он не является обязательным, таким образом 
узнать размер будущего файла заранее часто невозможно. В этом случае нам может помочь класс стрима `LimitSizeStream`,
реализованный ранее. Если мы включим его в цепочку обработки запроса, то как только размер файла превысит заданный 
лимит - стрим бросит ошибку и таким образом мы можем прекратить прием и сохранение файла. Не стоит также забывать, что
часть файла уже может быть на диске к моменту достижения лимита, так что его тоже надо удалить. В результате код будет 
выглядеть подобным образом:

```js
const limitStream = new LimitSizeStream({limit: 1e6});

req
  .pipe(limitStream)
  .pipe(stream);

limitStream.on('error', error => {
  if (error.code === 'LIMIT_EXCEEDED') {
    res.statusCode = 413;
    res.end('File is too big');
  } else {
    res.statusCode = 500;
    res.end('Internal server error'); 
  }

  fs.unlink(filepath, err => {});
});
``` 
